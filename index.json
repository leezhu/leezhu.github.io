[{"categories":["求职"],"content":"酷狗音乐后端工程师招聘 酷狗自从16年加入腾讯音乐娱乐集团后，企业发展前景一路开挂(毕竟抱大腿)，已于18年登陆纳斯达克，作者也是那一年加入公司，见证了公司上市的辉煌。作为已经发展了十多年的老企业，由于历史原因，为求稳定，技术栈会相对而言偏于老旧(毕竟尾大不掉)。但是这两年后端已经逐渐在往Golang、Docker等新技术转。随着加入集团，招聘要求会逐渐越来越高。但是，目前招聘还是酷狗业务线自行招聘，要求不高，正是加入的好时机。从我呆了两年的情况来看，酷狗还是由许多值得加入的优点： 福利待遇在广州中等偏上，年终还是非常可观; 题外话：加油肝 招聘要求不高，Leetcode 简单水平，重开发经验。 3～5年经验的开发会比较好。 互联网该有的福利，报销、夜宵啥的都有。 处于技术的转型期，还是非常容易做出成绩的 毕竟965的公司还真不多了 有意向，在官网职位地址看好职位后，发我邮箱，给你极速内推。空闲的时候可以给你简历把把关，交流交流。 ","date":"2020-06-26","objectID":"/hr/:1:0","tags":["内推","酷狗","后端开发"],"title":"[内推]酷狗音乐后端工程师招聘","uri":"/hr/"},{"categories":["求职"],"content":"邮箱leezhu@hnu.edu.cn联系我，欢迎交流学习 许可协议：CC BY-NC-ND 4.0 ","date":"2020-06-26","objectID":"/hr/:2:0","tags":["内推","酷狗","后端开发"],"title":"[内推]酷狗音乐后端工程师招聘","uri":"/hr/"},{"categories":["工具"],"content":"Hugo安装和新建博客 ","date":"2020-06-26","objectID":"/hugo/:1:0","tags":["hugo","博客"],"title":"Hugo博客搭建","uri":"/hugo/"},{"categories":["工具"],"content":"博客主题使用 ","date":"2020-06-26","objectID":"/hugo/:2:0","tags":["hugo","博客"],"title":"Hugo博客搭建","uri":"/hugo/"},{"categories":["工具"],"content":"新建第一篇博文 ","date":"2020-06-26","objectID":"/hugo/:3:0","tags":["hugo","博客"],"title":"Hugo博客搭建","uri":"/hugo/"},{"categories":["工具"],"content":"推送到GitPage 这。。。本想写一篇，才发现，噢。中文官网都给你写好了。照葫芦画瓢就行。 可能就是主题的下载和配置使用会稍微复杂点。因为每个主题的配置可能会不一样，但是主题的github都写的很明白，直接看。 ","date":"2020-06-26","objectID":"/hugo/:4:0","tags":["hugo","博客"],"title":"Hugo博客搭建","uri":"/hugo/"},{"categories":["工具"],"content":"开通评论功能Gittalk 我是用的这个主题默认是已经写好了这个评论功能的html部分，所以我只需要配置github的key和密钥就行。 具体可以参考这个博文 许可协议：CC BY-NC-ND 4.0 ","date":"2020-06-26","objectID":"/hugo/:5:0","tags":["hugo","博客"],"title":"Hugo博客搭建","uri":"/hugo/"},{"categories":null,"content":" 狂暴的欢愉必将有狂暴的结局 -《西部世界》，致敬那些为争取权利而发声的我们(韭浪) Shakespeare\" Shakespeare 一线互联网码农一枚，想要活出不一样的自我。 后端开发工程师、Python、Go初学者 不断寻找自己的兴趣与爱好,坚持做好每一件事,爱家人爱生活.三观正 ","date":"2020-06-26","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"极速内推酷狗音乐开发工程师 详情见我的贴子；内推 看中职位后发简历可极速内推。 官网职位地址 ","date":"2020-06-26","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"可邮箱leezhu@hnu.edu.cn联系我，欢迎交流学习， ","date":"2020-06-26","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["leetcode"],"content":"12. 整数转罗马数字 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: \"III\" 示例 2: 输入: 4 输出: \"IV\" 示例 3: 输入: 9 输出: \"IX\" 示例 4: 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路： 刚开始我打算用多个if else来区分4和9这种特殊情况，但是发觉过于繁琐，且代码量过多。也有许多同学提出很简单的python字符拼接方式，将所有情况都列举到二维数组里面，能够快速的找到罗马数字。后来经过评论区的朋友思维激发，题目中给的数值最大是3999，因此可以将1～1000中特殊的位置值全都罗列出来，再将要转换的数值从最高位进行拆分，把每一位从大到小进行整除。具体思路我还是通过代码进行讲解。 //测试需要导入bytes包 func intToRoman(num int) string { resultStr:=bytes.NewBuffer([]byte(\"\")) //建立一个byte数组 nums:=[13]int{1000,900,500,400,100,90,50,40,10,9,5,4,1} romanNums:=[13]string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"} for i:=0;i\u003c13;i++{ temp:=num/nums[i] //可以获取到每一位当前的倍数，例如3000就是3个1000 if temp\u003e0{ resultStr.Write(bytes.Repeat([]byte(romanNums[i]),temp)) //倍数就是出现的次数，将结果写入到最终的字符串中 num-=temp*nums[i] //减去最高位，例如2900变成900 }else{ continue //说明num比当前数组里面的值小，那么就找下一个进行比对 } } return resultStr.String() //bytes的字符串方法 } ","date":"2019-01-02","objectID":"/leetcode_12/:1:0","tags":["面试","刷题"],"title":"Leetcode_12","uri":"/leetcode_12/"},{"categories":["Golang"],"content":"面向对象 //method.go package main import ( \"fmt\" \"math\" ) type Rectangle struct { width, height float64 } type Cicle struct { radius float64 } func (r Rectangle) area() float64 { return r.width * r.height } func (r Cicle) area() float64 { return r.radius * r.radius * math.Pi } func main() { r := Rectangle{12.4, 12.4} c := Cicle{12.4} fmt.Println(\"rectangle is:\", r.area()) fmt.Println(\"cicle is:\", c.area()) } ------------------------ $ go run method.go rectangle is: 153.76000000000002 cicle is: 483.0512864159667 method方法其实就是类似于java中需要实现方法，将不同的类定义传过去。只是在struct中不要声明方法。 //method2.go test method change struct content package main import ( \"fmt\" ) const ( WHITE = iota BLACK BLUE RED YELLO ) type Color byte type Box struct { width, height, depth float64 color Color } type BoxList []Box func (b Box) Volume() float64 { return b.width * b.height * b.depth } //指针类型可直接更改传入类型的值 func (b *Box) SetColor(c Color) { b.color = c //这个地方go已经做优化，不需要显示的作为指针去调用方法 } func (b1 BoxList) BiggestColor() Color { v := 0.0 k := Color(WHITE) for _, b := range b1 { if bv := b.Volume(); bv \u003e v { v = bv k = b.color } } return k } func (b1 BoxList) PaintInBlack() { for i, _ := range b1 { b1[i].SetColor(BLACK) } } func (c Color) String() string { strings := []string{\"WHITE\", \"BLACK\", \"BLUE\", \"RED\", \"YELLOW\"} return strings[c] //c color是int索引 } func main() { boxes := BoxList{ Box{10, 1, 4, WHITE}, Box{4, 4, 4, RED}, } fmt.Println(\"box`s volume is=\", boxes[1].Volume()) fmt.Println(\"color of last one is \", boxes[len(boxes)-1].color.String()) } ","date":"2019-01-01","objectID":"/gobase3/:1:0","tags":["golang"],"title":"Go语言基础（三）","uri":"/gobase3/"},{"categories":["Golang"],"content":"method方法继承 匿名字段实现的方法可以被包含它的struct调用 type Student struct{ age int name string Human } type Employee struct{ age int name string Human } type Human struct{ talk string } func (h *Human)SayHi(){ //匿名字段定义的方法 fmt.Println(\"i can say hi\") } func main(){ student:=Student{Human{\"Yes\"},12,\"leezhu\"} employee:=Employee{Human{\"No\"},20,\"leezhu\"} student.SayHi() employee.SayHi() //可以继承匿名字段的方法 } ","date":"2019-01-01","objectID":"/gobase3/:2:0","tags":["golang"],"title":"Go语言基础（三）","uri":"/gobase3/"},{"categories":["Golang"],"content":"流程相关 ","date":"2018-12-28","objectID":"/gobase2/:1:0","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"1、for for在很多编程语言都是有的，golang的for循环与c有点不太一样，倒像是结合了c与python的特性。 for k,v:=range array{ } for i:=0;i\u003e10,i++{ //i只在此函数内生效 } sum:=100 for sum\u003c200{ //可以当作while来使用， } ","date":"2018-12-28","objectID":"/gobase2/:1:1","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"2、if 其实if语言没有什么过多想讲的，但是golang的if有一个特性需要注意一下 if i:=1;i\u003e10{ //在条件表达式里面可以短变量赋值。所以一般可以直接将需要判断的函数放在表达式里面。 } if x:=myFunc();x\u003e10{ } ","date":"2018-12-28","objectID":"/gobase2/:1:2","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"3、switch switch主要用于判断条件简单的，明确的，切分支多的。switch在每个分支里面找到了是自带break的，如果没有找到则继续往下走。 sum:=2 swith sum{ case 1: fmt.Println('found',sum) case 2,3,4: fmt.Println(\"found\") default: fmt.Println(\"No found\") } ","date":"2018-12-28","objectID":"/gobase2/:1:3","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"4、break、continue、goto 似乎每个编程语言都离开不开前两者，goto由于容易破坏语言的流程结构在c语言中被用的很谨慎，当然在go中也是如此，不到万不得已也别使用，不然很难维护，代码可读性也非常差。 for i:=1;i\u003e10;i++{ if i==2{ break/continue } } flag: fmt.Println(\"goto here) for i:=1;i\u003c10;i--{ if i==2{ goto flag } } ","date":"2018-12-28","objectID":"/gobase2/:1:4","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"函数相关 go函数是以关键字func标明的。一般格式是func myFunc(a int,b string)(int,string){} 可返回多参数内容。例如： func findMax(a,b int)int{ //返回一个参数内容 if a\u003eb{ return a } return b } func findMaxAndMin(a int,b int)(max int,min int){ if a\u003eb{ //有两个返回值 return a,b } return b,a } //一般多返回值我们会用在其中一个返回错误标记位 //返回值虽然命名了类型，也还要命名下参数名，这样利于代码可读性 //变参 func variArgs(varibel ...int){ //变参指的是参数的个数是无法确定的。我们编译程序的时候传入的参数就是一个slice多参数。还有就是在go基础一中数组初始化时的多元素个数也是用...来标示的。 } ","date":"2018-12-28","objectID":"/gobase2/:2:0","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"1、传值与传引用 官方说法都采用指针，似乎指针听起来更理解，引用就是对别人的链接，相当于自身并不存有对方的值，而只是可以得到对方值的路径。之前在基础1中我就讲到slice和map都是底层数据类型的引用，相当于在底层结构上面裹了一层，高级数据结构就是这么来的，一层层裹，特性会越来越多，兼容性也越来越强。 现在我们要讲的是函数传参的时候，是传引用还是传自身的值，还是拷贝呢？ 首先我么看一个例子： //简写我略去了包声明和引入包 func changeValue(a int)int{ a:=5 return a } value:=6 changeValue(value) --------- 结果：value=6 这是因为我们传入的a是value的副本(copy)，因此就算在函数内更改了a的值也影响不到value本身。如果要在函数内改变传入的值，那么就得用引用类型。 func changeValue(a *int)int{ *a:=*a+1 return *a } value:=6 changeValue(\u0026value) ---------- 结果：value=7 可以看到，通过引用我们改变了value值。可以这么理解，引用链接放到哪里都能找到原有值，但是传值只是传个副本，影响不到原有值本身。而且传引用还可以节省内存开销，但是也有弊端就是需要谨慎用。 ","date":"2018-12-28","objectID":"/gobase2/:2:1","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"2、defer defer是延迟操作，类似于python的finally，就是说无论如何都是会执行此语句。只不过defer是在函数内推出时。它是一个先进后出的操作。 func readFile()bool{ file.open(\"file.txt\") defer file.close() file... operation//各种操作 //但是一旦出现操作错误前，最终都会执行defer的语句。这种就能保证文件能够正常的关闭。 } //可以试下以下程序,观察现象 func myPrint(){ for i:=0;i\u003c5;i++{ defer fmt.Printf(\"%d\",i) } } --------- 结果： 9 8 7 6 5 4 3 2 1 //这是因为，第一个defer是不输出值的，然后进入了第二个defer,到达最后一个的时候。开始准备退出for，这个时候就开始后进先出了 ","date":"2018-12-28","objectID":"/gobase2/:2:2","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"3、函数作为类型 type myFunc func(int)bool 可用于实现多态，例如： type myFunc func(int)bool func isOdd(value int)bool{ if value %2!=0{ return true } return false } func isEven(value int)bool{ if value%2==0{ return true } return false } //check函数可以把myFunc当作类型传入 func check(a int,f myFunc)bool{ return f(a) } ","date":"2018-12-28","objectID":"/gobase2/:2:3","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"main和init函数 ","date":"2018-12-28","objectID":"/gobase2/:3:0","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"1、main函数 main函数是一个程序的入口，不需要自己调用。package main包必须只能包含一个main函数入口。 ","date":"2018-12-28","objectID":"/gobase2/:3:1","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"2、init函数 go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性， 有下面的特征： init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 每个包可以拥有多个init函数 包的每个源文件也可以拥有多个init函数 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明) 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用 当出现嵌套包的情况，会把所有根源的包都导入进来。例如：a1导入包b1,但b1包倒入c1，这样一级一级的把所有包都导入进来 但是使用init函数也有以下几个原则： 一个package或者是go文件可以包含多个init函数 init函数是在main函数之前执行的 init函数被自动调用，不能在其他函数中显示调用 package main import ( \"fmt\" ) func main(){ fmt.Println(\"do main\") } func init() { fmt.Println(\"do in init1\") } func init() { fmt.Println(\"do in init2\") } ----------- 结果：do in init1 do in init2 do main 可以看到上面代码执行的顺序，init是先于main执行的。一个包里面可以有多个init函数。 ","date":"2018-12-28","objectID":"/gobase2/:3:2","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"模块导入import 模块导入有两种方式，一种是import \"fmt\" 绝对路径，另外一种是相对路径。 ","date":"2018-12-28","objectID":"/gobase2/:4:0","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"1、点操作 import . \"fmt\"这样导入后，在代码中fmt.Println可以写成Println。这是将导入符略去了，但是不建议大家这样，如果出现多个模块中相同的函数，那么会有冲突。 ","date":"2018-12-28","objectID":"/gobase2/:4:1","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"2、别名替换 可以给要导入的模块加上别名，这有点类似于python中as的做法。import f \"fmt\"，所以可以缩写成f.Println() ","date":"2018-12-28","objectID":"/gobase2/:4:2","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"3、单纯导入操作 有些时候你只是想用包里面的初始变量名，并不需要用到函数。这个时候可以用到我们之前在基础一中说到的_下划线占位符，可以用下划线当作别名占位。import _ \"fmt\" ","date":"2018-12-28","objectID":"/gobase2/:4:3","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"struct类型 struct类型和c/c++里面的struct结构体有点类似，但是定义和声明的方式还有些不同。我们可以定义申明struct如下： type person struct{ //定义 name string age int } //初始化方式1 var Person1 person Person1.name=\"leezhu\" Person1.age=10 fmt.Printf(\"name is %s,age=%d\",Person1.name,Person1.age) //初始化方式2---顺序初始化 Person2:=person{\"leezhu\",10} //初始化方式3---通过k:v方式初始化,任意顺序 Person3:=person{name:\"leezhu\",age:10} //初始化方式3--初始化*Person4 指针类型 Person4:=new(person) *Person4.name=\"leezhu\" *Person4.age=10 以上是struct类型的一般运用，但是struct也有高级应用，例如struct匿名结构。 type person struct{ name string age int human //匿名对象，就是包含另外一个结构体,嵌入字段，不写类型 } type human struct{ eat string talk string age int } var Person5 person person.human=human{eat:\"noodle\",talk:\"chinese\"} Person6:=person{\"leezhu\",10,human{\"noodle\",\"chinese\"}} //访问字段，可以当作当前类型直接使用,这是因为匿名字段是实现了字段的继承。 fmt.Println(\"eat =\",Person5.eat) //有人注意到human 和student都有age，那当Person5.age是访问哪一个呢？Go里面很简单的解决了这个问题，最外层的优先访问，也就是访问student里面的age ","date":"2018-12-28","objectID":"/gobase2/:5:0","tags":["golang"],"title":"Go语言基础（二）","uri":"/gobase2/"},{"categories":["Golang"],"content":"关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 注意:关键字不可以使用 ","date":"2018-12-27","objectID":"/gobase1/:1:0","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"变量声明 ","date":"2018-12-27","objectID":"/gobase1/:2:0","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"1、一般声明 ​ 1、显示声明：var variable int ,变量名是在后面 ​ 2、隐式声明：var variable = 1, 没有类型 ​ 3、简短声明：varible:=1 . ​ 4、多变量声明：varible1,varible2:=1,2, ​ 5、_,varible:=1,2. 下划线 _一般用于占位符，不进行使用，可以用于索引等 ","date":"2018-12-27","objectID":"/gobase1/:2:1","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"2、分组声明 const ( i=100 j=200 ) var ( a=100 b=200 ) **注意：**go语言是可以不声明类型直接用，但是简短声明是必须在函数内生效，不可用于包内。go和python 有很多类似的地方。分组声明针对于同一种类型的变量可以放在一起声明 ","date":"2018-12-27","objectID":"/gobase1/:2:2","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"常量 ​ const:是常量的标志，可以定义为多个类型，例如： ​ 1.const constName =value ​ 2.const pi float=3.14 ​ 3.const Max=\"prefix” ","date":"2018-12-27","objectID":"/gobase1/:3:0","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"变量类型 ​ 1、Boolean类型：true/false ​ 2、rune/int/int8/int16/int32/…等等，具体可以百度，会根据编译器的32/64位来决定长度。int和int32类型长度一致，但是不可通用 ​ 3、float32/float64:无float类型 ​ 4、string:字符型。例如：var varible=\"1233”,或者多行数据用反斜引号。var hello =`wowoowowo` ","date":"2018-12-27","objectID":"/gobase1/:4:0","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"变量可用性 变量命名规则遵循驼峰原则 大写字母开头的变量/函数名是public，可以被其他包直接用。只能在当前包可用 小写字母开头的变量/函数名是private,不可被其他包直接用 ","date":"2018-12-27","objectID":"/gobase1/:5:0","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"高级数据结构 ","date":"2018-12-27","objectID":"/gobase1/:6:0","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"1、Array数组 var varible [10]int,array长度不可变，默认赋值是0 数组初始化：var varible[10]int ​ varible[0]=1 ​ a:=[3]int{1,2,3}//指定个数初始化 ​ a:=[...]int{1,2,3,4,5}//可自动计算元素个数 多维数组初始化： doubleArray:=[2][4]int{[4]int{1,2,3,4},[3]int{1,2,3}} doubleArray:=[2][4]int{} ","date":"2018-12-27","objectID":"/gobase1/:6:1","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"2、slice-动态数组 ​ 声明：var flslice[]int可以没有长度。底层实现还是array,只是是引用而已。 ​ 声明并初始化数据：flslice:=[]int{1,2,3,4,5} ​ 取值：flslice[i:j],遵循左闭右开的原则，即[1，2)这样。 ​ 切片：flslice[1:2],flslice[2:3] *提示：*slice和数组切片操作可参照python的list操作，基本类似 ","date":"2018-12-27","objectID":"/gobase1/:6:2","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"3、map-映射 map与python的dict是类似的，k-v结构，key可以是int或者string等类型。map和slice一样都是引用类型，没有长度限制。make函数用于内建类型（map, slice,channel）进行内存分配 ​ **声明：**var numbers map[string] int,key是string,value是int类型 ​ numbers:=make(map [string]int) ​ numbers['1']=2 //直接赋值 ​ **初始化：**rating:=map [string]float32{\"c\":23,\"b\":2} ​ 安全取值： value,ok := rating['c'] if ok{ fmt.Println('have found ',value) }else{ fmt.Println('not found') } ","date":"2018-12-27","objectID":"/gobase1/:6:3","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"4、make与new的区别 make是指定slice、map、channal这三种类型分配内容，返回的是类型的零值 new是建立内存，返回的是指针。 ","date":"2018-12-27","objectID":"/gobase1/:6:4","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["Golang"],"content":"5、零值 是类型变量填充前的默认值，int类型的都是0，字节或者16进制值会有点不一样。布尔型是false,string类型是”\". 注意：引用类型会被另外一个引用改变，想想可不可以加const就不会被改变了。 ","date":"2018-12-27","objectID":"/gobase1/:6:5","tags":["golang"],"title":"Go语言基础（一）","uri":"/gobase1/"},{"categories":["数据库"],"content":"长期在用sql，所以想对mysql做一下简要的整理，主要是最近自己工作需要用到的，和写代码要注意sql语句的地方。 ","date":"2018-10-14","objectID":"/mysql_index/:0:0","tags":["Mysql","索引"],"title":"Mysql索引操作","uri":"/mysql_index/"},{"categories":["数据库"],"content":"Tips Update：不能用子查询，例如update table_name set xx='' where id in (select id ....),mysql5.7不支持，只能用inner join方式进行处理，将此表联合起来处理。正确姿势是update table_name a inner join(select id from table where id\u003e=.. limit 1,1)t on a.id=t.id set a.'字段'=2;这段代码意思是指定范围内的id进行更新。 index：1、mysql的索引网上内容很多，这里详细就不赘述了。在实际开发中，对于上百万的行的mysql表来说，将经常查询的语句加上索引能够加快查询，不至于拖垮数据库。2、索引最好在建表的时候就想好建立，不然等到表行数超过上千万时，建索引非常慢。3、对于sql语句，索引的字段类型要符合表字段类型，例如字段是varchar类型，最好用字符型，这样能够加快查找。4、如果涉及数据库的程序比较慢时，最好查下数据库的慢查询日志，看是否是哪条记录。然后就进行优化。5、sql语句没有走索引会很慢，必要时可以加强制索引。 ","date":"2018-10-14","objectID":"/mysql_index/:1:0","tags":["Mysql","索引"],"title":"Mysql索引操作","uri":"/mysql_index/"},{"categories":["数据库"],"content":"Sql ","date":"2018-10-14","objectID":"/mysql_index/:2:0","tags":["Mysql","索引"],"title":"Mysql索引操作","uri":"/mysql_index/"},{"categories":["数据库"],"content":"1、添加索引： ALTER TABLE table_name ADD INDEX index_name (column1, column2,column3 ) ","date":"2018-10-14","objectID":"/mysql_index/:2:1","tags":["Mysql","索引"],"title":"Mysql索引操作","uri":"/mysql_index/"},{"categories":["数据库"],"content":"2、增加列： alter table TABLE_NAME add column NEW_COLUMN_NAME varchar(20) not null default '' comment ''; ","date":"2018-10-14","objectID":"/mysql_index/:2:2","tags":["Mysql","索引"],"title":"Mysql索引操作","uri":"/mysql_index/"},{"categories":["数据库"],"content":"3、修改索引： -- 先删除 ALTER TABLE user DROP INDEX idx_user_username; --再以修改后的内容创建同名索引 CREATE INDEX idx_user_username ON user (username(8)); ","date":"2018-10-14","objectID":"/mysql_index/:2:3","tags":["Mysql","索引"],"title":"Mysql索引操作","uri":"/mysql_index/"},{"categories":["工具"],"content":" 生活就像万花筒，缤纷精彩，于是便有了那些所谓的快乐、幸福。 xx-net是一个非常好用的翻墙软件，在windows下安装比较方便，但是随着我换Mac后发现没有一个完整的资料介绍安装过程，因此自己在这里介绍下如何安装。我用的Mac Pro17版，Mac安装XX-Net最大的坑就在于开启IPv6比较麻烦，需要关闭Mac权限控制，相当于手机root那种，我建议是安装需要开启IPV6的软件后，将权限又设置回来。Mac对隐私比较注重，因此在安装外部软件的时候，注意要在系统设置里面的隐私选项那里进入后选择一直允许。 ","date":"2018-10-02","objectID":"/mac_xx-net/:0:0","tags":["翻墙","Mac","Vpn"],"title":"Mac下安装XX—Net(翻墙)","uri":"/mac_xx-net/"},{"categories":["工具"],"content":"安装chrome xx-net使用的浏览器必须是Chrome，安装包不太容易找。安装完成时需要设定为默认浏览器。 ","date":"2018-10-02","objectID":"/mac_xx-net/:1:0","tags":["翻墙","Mac","Vpn"],"title":"Mac下安装XX—Net(翻墙)","uri":"/mac_xx-net/"},{"categories":["工具"],"content":"下载xx-net 可直接下载xx-net解压，在文件里面有一个SwitchyOmega文件夹，将.crx文件放入chrome://extensions扩展程序里进行安装，注意需要打开开发者模式，拖拽到扩展程序页面安装即可。然后进入xx-net文件夹点击start文件，默认会终端打开，会自动打开浏览器。 ","date":"2018-10-02","objectID":"/mac_xx-net/:1:1","tags":["翻墙","Mac","Vpn"],"title":"Mac下安装XX—Net(翻墙)","uri":"/mac_xx-net/"},{"categories":["工具"],"content":"更新情景模式 进入启动xx-net自动打开浏览器的页面，点击左侧的Import/Export导入SwitchyOmega文件夹下的.bak备份情景模式文件。导入后，会在左侧多出几个自动切换模式，点击GAE-Proxy自动切换，然后在页面中点击立刻下载模式。启动xx-net后会提示\"仅 IPv6” 不可用，请检查这个时候就需要开启ipv6 ","date":"2018-10-02","objectID":"/mac_xx-net/:2:0","tags":["翻墙","Mac","Vpn"],"title":"Mac下安装XX—Net(翻墙)","uri":"/mac_xx-net/"},{"categories":["工具"],"content":"关闭Mac权限控制 Mac是限制安装第三方来源的软件，可以在终端中用csrutil status 命令来查看权限是否打开，如果是enable则需要关闭。可以按以下步骤进行操作： 重启开机的时候不停按住comman + r键，会进入修复模式。 在上面选择终端，输入csrutil disable会提示关闭成功，然后重启电脑。 ","date":"2018-10-02","objectID":"/mac_xx-net/:2:1","tags":["翻墙","Mac","Vpn"],"title":"Mac下安装XX—Net(翻墙)","uri":"/mac_xx-net/"},{"categories":["工具"],"content":"安装开启IPv6软件 下载安装tuntaposx 下载安装mired,注意的是需要将在系统设置中，点击安全与隐私设置，允许一直打开其他来源安装。否则pkg包不会允许安装。 ","date":"2018-10-02","objectID":"/mac_xx-net/:2:2","tags":["翻墙","Mac","Vpn"],"title":"Mac下安装XX—Net(翻墙)","uri":"/mac_xx-net/"},{"categories":["工具"],"content":"启动xx-net 一切准备就绪后就可以运行xx-net了，在XX-Net文件夹下，点击start会自动打开Chrome，从页面中的状态我们可以看到一切ok，然后选择右侧switchyomega图标中GAE-Proxy自动切换，这时候我们键入google检验安装是否成功。如果不能访问，检查前面5个步骤是否都做到位。 ","date":"2018-10-02","objectID":"/mac_xx-net/:2:3","tags":["翻墙","Mac","Vpn"],"title":"Mac下安装XX—Net(翻墙)","uri":"/mac_xx-net/"},{"categories":["求职"],"content":" 　真正的快乐是内在的，它只有在人类的心灵里才能发现。——布雷默 秋招整体算是在昨天下午结束了，已经收到了酷狗音乐的offer，工作岗位和薪资都挺满意的，就等着过几天签约了。秋招这一个月左右走过来，其实自我最大的变化是一个心态问题，有心插秧秧不长，无心插柳柳成荫，这句话最能表达我的感受。 从九月十号开始，陆陆续续投递了超过50+家公司，笔试也将近有30+公司吧，有些是冲突了没做，有些是简历挂了，不过也是少数，面试的公司10+家吧。有时候一天做两三场笔试是很平常的事。也许会感到好奇，为什么我会投如此多公司，面试却这么少？首先投这么多公司是我本身对秋招的恐惧，怕找不到工作，投递公司越多，机会越大，越能平定下自我的焦虑心情。其次，不投递公司而是仅仅等待笔试又是一种深深的折磨，你会感觉到这种压抑，没事干。所以多投，别想太多，别想着公司不好什么的，也是瞎投。然而去不去首先是得你拿到这个offer才有资格这么说嘛。其实今年我们学校计算机招聘的都来的很早，九月多基本上都招聘完了，一天二十多个公司都是可能想去的。以至于那三周非常的累，到了国庆一放松，后面的招聘会都疲软了，都不太想去。我们辅导员都在向我们吐槽，有些公司来了很多面试官，居然一个湖大的学生都没有。其实国庆后，整个院签了一半以上，都差不多了。 ","date":"2017-09-17","objectID":"/find_job/:0:0","tags":["面试","秋招","酷狗","大厂"],"title":"秋招找工作那点事","uri":"/find_job/"},{"categories":["求职"],"content":"准备笔试 接下来我想讲讲求职的现状，首先从我观察来看，按语言来分，java找工作面还是很广的，进互联网公司更容易，薪资也是很高的，特别是做大数据的，简直高的离谱，我有个同学还说要我下辈子去学大数据，我也只能呵呵了。c++找工作分两块，要么后端开发，要么就是软件开发，对于求职还是比java吃力。当然了，我不是说建议因为找工作而去学习那种语言，首先看自己兴趣爱好，是否偏向于应用，还是偏服务器端。如果都没有的话，那就选java吧，入手快，工作也好找。语言确定下来的话，就需要做相应的准备了。首先强调，我说的只适用于找互联网工作，如果是银行，国企等不适用，可做参考。首先讲讲笔试这块，我觉得只有一个诀窍： 去牛课网使劲刷题 刷剑指offer算法 刷过去BAT美团等公司的校招卷子 然后结合着书本，包括数据库、操作系统、Linux、网络等。这样边刷题边看书做笔记提高会很快。当然了，想进互联网公司，我觉得算法是非常重要的东西，首先剑指offer上的题目能随手写出来，常用排序必须会。然后其次再去刷leetcode题目，如果做的差不多，那一面就很稳了。如果平时空余时间，或者睡觉前，可以刷刷牛课网上的BAT面经，也是非常有用。我这可不是托哦，只是觉得牛课网确实对我找工作起了非常大的作用。 ","date":"2017-09-17","objectID":"/find_job/:0:1","tags":["面试","秋招","酷狗","大厂"],"title":"秋招找工作那点事","uri":"/find_job/"},{"categories":["求职"],"content":"准备面试　 接着是面试这块，项目！项目！项目！重要的事情讲三遍，一定需要弄个项目经验，不然就要和面试官尬聊了。可以去网上找不错的项目，然后自己从头到尾做一遍，明白原理，过程。这样就是你的了。要是自己搞不懂，那就别露馅了，老铁那就扎心了。**开源项目！开源项目！开源项目！**对，就是开源项目，最好自己参与你那个方向不错的开源项目，而且必须当前比较火的，自己看源码，搞懂一部分，就可以吹牛逼了。说了这些，你离BAT已经很近了。再就是学习下如今比较常用的框架等，如java里面的jvm，spring，mybatis等，因为我是做c++的，所以java这方面不多讲了，具体哪些流行的，请自行百度。有了这些，就再看看程序员面试宝典，这么下来也差不多了。老铁那就稳了。 以上自己讲的也挺粗略的，其实一句话就可以概括，早点准备，早点刷题，那就差不多了。再补一句，实习进BAT是最容易的，当然也要冒着实习留不下来的风险，就算没留下来，你也要准备秋招，也算赚到互联网公司实习经验了。祝大家都找到心仪的工作。 ","date":"2017-09-17","objectID":"/find_job/:0:2","tags":["面试","秋招","酷狗","大厂"],"title":"秋招找工作那点事","uri":"/find_job/"},{"categories":["感悟"],"content":" 为你千千万万遍 这篇小说讲的富人少爷阿米尔和“仆人”哈桑之间的友谊故事。 看完前序，我隐隐约约感受到作者透露出的一种愧疚和悲伤感，这在我脑海里浮现出了一个词，“友谊的背叛”。我抱着浓厚的兴趣一页页翻看，期待如此的情节出现。终于，在哈桑替阿米尔找回蓝色风筝的那一节，发生了情理之中的事，阿塞夫把哈桑“强暴”了。正如阿塞夫所言“他从来没有把你当朋友，他为什么总是在闲暇的时候找你玩，为什么从来不叫你和其他人一起玩，你就是他的宠物，玩偶。你为什么还如此忠诚”。可是哈桑内心很坚定，对阿米尔的忠诚。这些话一次次触动阿米尔的内心，哈桑对他是多么的好啊，多么的了解他。阿米尔在远处听着，可是他没有动。他在内心的煎熬，他的懦弱占据了他的思想。他选择了逃避。 阿米尔没有把哈桑当做朋友，是因为自己的懦弱，他内心的煎熬来自于道德的批判，他自己也在审视着自己的行为，奶妈讲过，喝过同一个胸的奶长大的人是兄弟，他明白，他们俩是兄弟。可是他始终没有放下自己的偏见，没有像他父亲那样的勇敢，那么正直，为了得到父亲的垂爱，屡次透支哈桑对他的爱。最后他没能在哈桑最危险的时候挺身而出。他的内心是痛苦的，他没有直面危险，抛弃了最真挚的朋友。而就因此走向了另外一条路。时时刻刻遭受着内心的谴责。 人的友谊是珍贵的，现在长大了懂了，可是对于像阿米尔只有十二岁的小孩来说，似乎懂，却又似乎不懂。我曾也有过一段真挚的友谊，和我关系特别好。正直高三那会，我和他一个床头。学习压力大，心情难免烦躁的，也正是因为一点小事，那天我冲他发火，说了几句。他没有回我，默声不对。后来我也没有较好的处理这个问题，导致对他很愧疚，虽然后面道过歉，可是友谊回不去了。那种纯真，真挚的感情也随风飘散。我宁愿时间吹散了我们友谊，也不愿自己亲手将它斩断，那种愧疚与悔恨是否又能懂。 原文出自我的csdb[博客](https://blog.csdn.net/zlhn55/article/details/74908455) 许可协议：CC BY-NC-ND 4.0 ","date":"2017-07-10","objectID":"/kite/:0:0","tags":["读后感","生活"],"title":"读《追风筝的人》有感","uri":"/kite/"},{"categories":["算法"],"content":"基本概念 遗传算法是根据生物进化理论得来的，在自然社会中，我们染色体的交叉变异都是随机的，适应能力强的生物得以抵抗恶劣环境发生变异能够存活下来，而适应能力不强的将消亡。 基于这种概念，我们是否可以考虑，在求最优值时，利用随机的变异交叉，迭代(可以认为是繁殖的多少代)，将变异后好的样本值(目标值好的)留下来，然后将差的后代去掉，用好的来繁殖，进行迭代，这就是我们所说的优生优育啊。基因好的就该多生，目前这我们还没这政策呢。 ","date":"2016-03-28","objectID":"/inheritance/:1:0","tags":["遗传算法"],"title":"大话智能优化算法之遗传算法","uri":"/inheritance/"},{"categories":["算法"],"content":"举例 我举个简单例子，假如我求一个连续函数的最大值，比如y(x)=x2(这里是x的平方),x范围为[-2,2]。这个函数的函数值就是我们的适应度啊，有的x对应的函数值大，就留下来，有的很小我就用好的替换掉。 万物都是起源的对不，我也得首先给它造个亚当，夏娃啊。当然我们不只是造一个啦，我们造多个啊，这个群体人口基数大了才能迅速产生优良个体撒。 ","date":"2016-03-28","objectID":"/inheritance/:2:0","tags":["遗传算法"],"title":"大话智能优化算法之遗传算法","uri":"/inheritance/"},{"categories":["算法"],"content":"初始化 所以我们就先初始化样本个体，但是如何初始化啊，这个就涉及到编码问题了，学过生物我们都知道人体有23条染色体，染色体间是实现片段的交叉变异，但是我们这是一个值啊1,2,0.1等，这时我们就想到了用编码，二进制编码，反正只有0,1而且二进制和十进制之间是相互转换的嘛。但是我们取值的范围不是[-2,2]么，长度是4，转化为二进制就是100，很明显取值也只能是0，1,2,3,4，加上-2，就是可以取-2，-1,0,1,2。可是这个太短了吧样本，交叉变异都不好弄，这时我们发现我们精度不够，取值只有这几个呀，所以我们想到取精度为1呀，保留后一位，那取值长度个数就变成了4/0.1=40啊，这时二进制编码长度就有32~64之间，明显我们取6，即1000000，注意到其中的我们变量值x到基因值的转化，这个自己琢磨。 ","date":"2016-03-28","objectID":"/inheritance/:2:1","tags":["遗传算法"],"title":"大话智能优化算法之遗传算法","uri":"/inheritance/"},{"categories":["算法"],"content":"交叉变异 有了样本个体后我们就开始交叉，变异嘛，你要问我如何交叉，就是随机选两个样本来造下一代嘛，呃呃，不是酱紫的。就是随机先选择群体中的两个样本，然后用rand()随机生成在哪个位置交叉啊，就是两个样本在指定位置进行交换嘛，也就是交换0,1.一般的嘛，我们这么想交叉的越多，是不是进化的越快啊，想想人类也有几万亿年了。所以，看你设定随机交叉的次数了，交叉了我们就开始变异啊，这个更好办了，随机指定变异位置，反正就是0,1的变化。 ","date":"2016-03-28","objectID":"/inheritance/:2:2","tags":["遗传算法"],"title":"大话智能优化算法之遗传算法","uri":"/inheritance/"},{"categories":["算法"],"content":"筛选 这时我们就需要进行刷选了，有些样本不行就扔掉了。可是我们如何来确定好与坏呢，对的，我们还先计算函数值大小嘛，也就是y(x)的值。每个样本都这个适应度(函数值)。这就开始找吧，找到最好的，找到最差的，不过我们可是知道啊，每一代进化是不是有个最好的呀，然后从亚当夏娃开始，我们就记录一个更更好的个体，它是所有代里面最好的。然后呢，我们就需要将用这个最最好的个体来代替每一代选出来不行的样本啊，让它进化啊。一旦某一代出现了更好的样本，我们也需要更新这个最最好的样本嘛。 ","date":"2016-03-28","objectID":"/inheritance/:2:3","tags":["遗传算法"],"title":"大话智能优化算法之遗传算法","uri":"/inheritance/"},{"categories":["算法"],"content":"总结 这样，就完啦，遗传算法就这么简单呀，你给指定交叉变异来个100代，能得出最好的个体的。当然遗传算法还有许多变种，可是明白这最基础的原理是最重要的，有兴趣的可以解决离散问题的tsp问题，也很有意思。 原文出自我的csdb[博客](https://blog.csdn.net/zlhn55/article/details/50999573) 许可协议：CC BY-NC-ND 4.0 ","date":"2016-03-28","objectID":"/inheritance/:3:0","tags":["遗传算法"],"title":"大话智能优化算法之遗传算法","uri":"/inheritance/"},{"categories":["算法"],"content":"快速排序法的原理我就不多讲了，就是基于分冶的思想，所以一般用递归调用实现。至于具体原理网上一搜一大把，而我要讲的就是代码实现中具体代码部分的讲解。 ","date":"2015-10-15","objectID":"/quicksort/:0:0","tags":["快排","排序"],"title":"快速排序法两种代码实现方式讲解","uri":"/quicksort/"},{"categories":["算法"],"content":"第一种实现方式 //快速排序第一种方式实现 void quick_sort(int s[], int l, int r) { if (l \u003c r) { //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1 int i = l, j = r, x = s[l]; while (i \u003c j) { while(i \u003c j \u0026\u0026 s[j] \u003e= x) // 从右向左找第一个小于x的数 j--; if(i \u003c j) s[i++] = s[j]; while(i \u003c j \u0026\u0026 s[i] \u003c x) // 从左向右找第一个大于等于x的数 i++; if(i \u003c j) s[j--] = s[i]; } s[i] = x; quick_sort(s, l, i - 1); // 递归调用 quick_sort(s, i + 1, r); } } 其实这种方法，在网上是讲的最多的，而且很详细，就是从两端开始。i,j分别与比较量(一般是首个数或者中间量)进行比较，比它小的替换掉放一边，比它大的放另外一边。最后再把比较量放到分割位置。 ","date":"2015-10-15","objectID":"/quicksort/:1:0","tags":["快排","排序"],"title":"快速排序法两种代码实现方式讲解","uri":"/quicksort/"},{"categories":["算法"],"content":"第二种实现方式 //快速排序第二种实现方式 void qsort(int v[],int left,int right) { int i, last; void swap(int v[],int i,int j);//交换两个数 if(left \u003e= right) return; swap(v,left,(left+right)/2);//将中间数交换，防止第一个数就是最小或者最大，减小复杂度 last=left;//第一个数为比较量 for(i=left+1;i\u003c=right;i++) if(v[i]\u003cv[left]) swap(v,++last,i); swap(v,left,last); qsort(v,left,last-1); qsort(v,last+1,right); } 可以发现，这种代码实现方式比第一种简洁的很多，但是不够直观. 关键代码如下 last=left;//第一个数为比较量 for(i=left+1;i\u003c=right;i++) if(v[i]\u003cv[left]) swap(v,++last,i); swap(v,left,last); 第二种方式的实现是从一端开始的，我们可以这么想，比较量是第一个，即v[left]。后面的数v[i]都和它进行比较，i是个移动量，而last是一个在数组中做标记的，在标记的数后面的数都是比v[left]小的数， 每当v[i]小于v[left],last应该先+1,因为它自身是满足小于v[left]，所以需要将前面不满足的数替换掉，然后自己又指向了这个新的数，i也往后移一位。最后再将这个分割量v[left]交换到分割位置last。 这是对第二种实现方式代码图解方式 原文出自我的csdb[博客](https://blog.csdn.net/zlhn55/article/details/49155001) 许可协议：CC BY-NC-ND 4.0 ","date":"2015-10-15","objectID":"/quicksort/:2:0","tags":["快排","排序"],"title":"快速排序法两种代码实现方式讲解","uri":"/quicksort/"}]